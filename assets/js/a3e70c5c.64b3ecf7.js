(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[680],{7580:(e,t,i)=>{e.exports={src:{srcSet:i.p+"assets/ideal-img/confluence.723b242.1700.png 1700w",images:[{path:i.p+"assets/ideal-img/confluence.723b242.1700.png",width:1700,height:1288}],src:i.p+"assets/ideal-img/confluence.723b242.1700.png",toString:function(){return i.p+"assets/ideal-img/confluence.723b242.1700.png"},placeholder:void 0,width:1700,height:1288},preSrc:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVQYlZVQWw4EIQjz/oeaQ8xNdOIDULopO5M4+7ckjVgKVZK7g2DMOVFrxRgj7n7Xli+kYG6ylAJVDbGIPKWIxClrrRBwEk8zi5w888MPJBK9d7TWXhNsGq58oYyCU8+vkCKK96BTzhkyBNDNmm+iLUFut/7vM/t62E3B73qID1OdOncRbgVJAAAAAElFTkSuQmCC"}},4590:(e,t,i)=>{"use strict";i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>m});var a=i(5773),n=(i(7378),i(5318)),c=i(3840);const o={id:"matching-acceleration",title:"Matching VM Acceleration"},r=void 0,s={unversionedId:"internals/matching-acceleration",id:"internals/matching-acceleration",title:"Matching VM Acceleration",description:"Describes how to accelerate regular expression matching.",source:"@site/docs/internals/matching-acceleration.mdx",sourceDirName:"internals",slug:"/internals/matching-acceleration",permalink:"/recheck/docs/internals/matching-acceleration",draft:!1,editUrl:"https://github.com/makenowjust-labs/recheck/tree/main/website/docs/internals/matching-acceleration.mdx",tags:[],version:"current",frontMatter:{id:"matching-acceleration",title:"Matching VM Acceleration"},sidebar:"docs",previous:{title:"Fuzzing with Static Analysis",permalink:"/recheck/docs/internals/fuzzing"},next:{title:"Criteria to Decide Algorithm",permalink:"/recheck/docs/internals/criteria"}},l={},m=[{value:"Regular Expression Matching",id:"regular-expression-matching",level:2},{value:"Acceleration by Memoization",id:"acceleration-by-memoization",level:2}],h={toc:m};function u(e){let{components:t,...o}=e;return(0,n.kt)("wrapper",(0,a.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Describes how to accelerate regular expression matching."),(0,n.kt)("h2",{id:"regular-expression-matching"},"Regular Expression Matching"),(0,n.kt)("p",null,"Regular expression matching is done many times during fuzzing, so it is important to accelerate it. Although many methods to accelerate matching have been studied, it is not easy to use them directly for ",(0,n.kt)("inlineCode",{parentName:"p"},"recheck")," fuzzing, because we want to determine how long matching takes, so we have to accelerate it and mimic the behavior of existing matching implementations at the same time."),(0,n.kt)("p",null,"A typical method to speed up regular expression matching is to construct a deterministic finite state automaton (DFA). In some cases, instead of actually constructing a DFA, we can execute the states of the NFA in parallel and cache the same set of states. However, it is difficult to mimic the priority of backtracking because these methods hide the structure of backtracking, and they cannot interpret backreferences correctly because they rely on finite state automata."),(0,n.kt)("p",null,"Therefore, we decided to use selective memoization by Davis et al. in ",(0,n.kt)("inlineCode",{parentName:"p"},"recheck"),"."),(0,n.kt)("h2",{id:"acceleration-by-memoization"},"Acceleration by Memoization"),(0,n.kt)("p",null,"The key idea in Davis et al.'s work is the following"),(0,n.kt)("admonition",{title:"Theorem (NFA matching memoization)",type:"info"},(0,n.kt)("p",{parentName:"admonition"},"When matching by NFA backtracking, if it memoizes the results from the confluence of branches in the transition diagram, it will reach a certain state at a certain position in the input string at most once.")),(0,n.kt)("p",{className:"text--center"},(0,n.kt)(c.Z,{img:i(7580),max:300,width:"300px",mdxType:"Image"})),(0,n.kt)("p",null,"By using this theorem, the time taken for regular expression matching can be made linear to the length of the input string in most cases. Furthermore, since it actually performs backtracking matching, it can mimic the behavior of exact backtracking by recording the number of times a character is read from the confluence until the matching fails, and adding it when it reaches the confluence again."),(0,n.kt)("p",null,"However, since the implementation of regular expression matching in ",(0,n.kt)("inlineCode",{parentName:"p"},"recheck")," is based on VM, it should be applied to the confluence of branch instructions, instead of the confluence of branches in the transition diagram."),(0,n.kt)("h1",{id:"notes"},"Notes"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The same acceleration against backreferences can be done by memoizing including the captured positions, but this may actually slow down the matching. Thus, ",(0,n.kt)("inlineCode",{parentName:"li"},"recheck")," does not perform this acceleration by default when backreferences are included."),(0,n.kt)("li",{parentName:"ul"},"At this time, we do not adopt the compression for the memoization data structure in Davis et al.\u2019s research.")),(0,n.kt)("h1",{id:"references"},"References"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{id:"davis-2021"},"[1]"),' Davis, James C., Francisco Servant, and Dongyoon Lee. "Using selective memoization to defeat regular expression denial of service (ReDoS)." ',(0,n.kt)("em",null,"2021 IEEE Symposium on Security and Privacy (SP), Los Alamitos, CA, USA"),". 2021.")))}u.isMDXComponent=!0}}]);