"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[277],{5318:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>s});var i=a(7378);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},l=Object.keys(e);for(i=0;i<l.length;i++)a=l[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)a=l[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var m=i.createContext({}),p=function(e){var t=i.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=p(e.components);return i.createElement(m.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},k=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,m=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(a),k=n,s=c["".concat(m,".").concat(k)]||c[k]||d[k]||l;return a?i.createElement(s,r(r({ref:t},u),{},{components:a})):i.createElement(s,r({ref:t},u))}));function s(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,r=new Array(l);r[0]=k;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o[c]="string"==typeof e?e:n,r[1]=o;for(var p=2;p<l;p++)r[p]=a[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}k.displayName="MDXCreateElement"},4218:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var i=a(5773),n=(a(7378),a(5318));const l={id:"parameters",title:"Parameters"},r=void 0,o={unversionedId:"usage/parameters",id:"usage/parameters",title:"Parameters",description:"Parameters is an object type to specify detailed checker behavior.",source:"@site/docs/usage/parameters.md",sourceDirName:"usage",slug:"/usage/parameters",permalink:"/recheck/docs/usage/parameters",draft:!1,editUrl:"https://github.com/makenowjust-labs/recheck/tree/main/website/docs/usage/parameters.md",tags:[],version:"current",frontMatter:{id:"parameters",title:"Parameters"},sidebar:"docs",previous:{title:"As ESLint Plugin",permalink:"/recheck/docs/usage/as-eslint-plugin"},next:{title:"Diagnostics",permalink:"/recheck/docs/usage/diagnostics"}},m={},p=[{value:"<code>accelerationMode</code>",id:"accelerationmode",level:2},{value:"<code>attackLimit</code>",id:"attacklimit",level:2},{value:"<code>attackTimeout</code>",id:"attacktimeout",level:2},{value:"<code>checker</code>",id:"checker",level:2},{value:"<code>crossoverSize</code>",id:"crossoversize",level:2},{value:"<code>heatRatio</code>",id:"heatratio",level:2},{value:"<code>incubationLimit</code>",id:"incubationlimit",level:2},{value:"<code>incubationTimeout</code>",id:"incubationtimeout",level:2},{value:"<code>logger</code>",id:"logger",level:2},{value:"<code>maxAttackStringSize</code>",id:"maxattackstringsize",level:2},{value:"<code>maxDegree</code>",id:"maxdegree",level:2},{value:"<code>maxGeneStringSize</code>",id:"maxgenestringsize",level:2},{value:"<code>maxGenerationSize</code>",id:"maxgenerationsize",level:2},{value:"<code>maxInitialGenerationSize</code>",id:"maxinitialgenerationsize",level:2},{value:"<code>maxIteration</code>",id:"maxiteration",level:2},{value:"<code>maxNFASize</code>",id:"maxnfasize",level:2},{value:"<code>maxPatternSize</code>",id:"maxpatternsize",level:2},{value:"<code>maxRecallStringSize</code>",id:"maxrecallstringsize",level:2},{value:"<code>maxRepeatCount</code>",id:"maxrepeatcount",level:2},{value:"<code>maxSimpleRepeatCount</code>",id:"maxsimplerepeatcount",level:2},{value:"<code>mutationSize</code>",id:"mutationsize",level:2},{value:"<code>randomSeed</code>",id:"randomseed",level:2},{value:"<code>recallLimit</code>",id:"recalllimit",level:2},{value:"<code>recallTimeout</code>",id:"recalltimeout",level:2},{value:"<code>seeder</code>",id:"seeder",level:2},{value:"<code>seedingLimit</code>",id:"seedinglimit",level:2},{value:"<code>seedingTimeout</code>",id:"seedingtimeout",level:2},{value:"<code>timeout</code>",id:"timeout",level:2}],u={toc:p},c="wrapper";function d(e){let{components:t,...a}=e;return(0,n.kt)(c,(0,i.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"Parameters")," is an object type to specify detailed checker behavior.\nIt has many parameters.\nBut, few parameters are useful to users, and the others are not needed to be set manually."),(0,n.kt)("p",null,"You can look at the whole type definition ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/makenowjust-labs/recheck/blob/main/packages/recheck/index.d.ts"},"here")," (TypeScript) or ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/makenowjust-labs/recheck/blob/main/modules/recheck-common/shared/src/main/scala/codes/quine/labs/recheck/common/Parameters.scala"},"here")," (Scala)."),(0,n.kt)("h2",{id:"accelerationmode"},(0,n.kt)("inlineCode",{parentName:"h2"},"accelerationMode")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"'auto' | 'on' | 'off'")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"AccelerationMode")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"'auto'")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"AccelerationMode.Auto")," (Scala)")),(0,n.kt)("p",null,"The type of acceleration mode strategy on fuzzing."),(0,n.kt)("p",null,"There are three acceleration mode strategies."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"auto")," uses acceleration mode as default. However, if the regular expression has backreferences, it turns off the acceleration mode."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"on")," turns on the acceleration mode."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"off")," turns off the acceleration mode.")),(0,n.kt)("h2",{id:"attacklimit"},(0,n.kt)("inlineCode",{parentName:"h2"},"attackLimit")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"1500000000"))),(0,n.kt)("p",null,"The upper limit on the number of characters read by VM on the attack."),(0,n.kt)("h2",{id:"attacktimeout"},(0,n.kt)("inlineCode",{parentName:"h2"},"attackTimeout")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number | null")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"1000")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration(1, SECONDS)")," (Scala)")),(0,n.kt)("p",null,"The upper limit of matching time on the attack."),(0,n.kt)("h2",{id:"checker"},(0,n.kt)("inlineCode",{parentName:"h2"},"checker")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"'auto' | 'fuzz' | 'automaton'")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Checker")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"'auto'")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Checker.Auto")," (Scala)")),(0,n.kt)("p",null,"The type of checker to be used."),(0,n.kt)("p",null,"There are three checker types."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"auto")," checker uses the criteria to decide which algorithm is better to use against a regular expression, the algorithm based on automata theory or the fuzzing algorithm."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"fuzz")," checker uses the fuzzing algorithm with static analysis."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"automaton")," checker uses the algorithm based on automata theory.")),(0,n.kt)("h2",{id:"crossoversize"},(0,n.kt)("inlineCode",{parentName:"h2"},"crossoverSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"25"))),(0,n.kt)("p",null,"The number of crossover on each generation."),(0,n.kt)("h2",{id:"heatratio"},(0,n.kt)("inlineCode",{parentName:"h2"},"heatRatio")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Double")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"0.001"))),(0,n.kt)("p",null,"The ratio of the number of characters read to the maximum number to be considered as a hot spot."),(0,n.kt)("h2",{id:"incubationlimit"},(0,n.kt)("inlineCode",{parentName:"h2"},"incubationLimit")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"25000"))),(0,n.kt)("p",null,"The upper limit on the number of characters read by VM on incubation."),(0,n.kt)("h2",{id:"incubationtimeout"},(0,n.kt)("inlineCode",{parentName:"h2"},"incubationTimeout")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number | null")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"250")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration(250, MILLISECONDS)")," (Scala)")),(0,n.kt)("p",null,"The upper limit of matching time on incubation."),(0,n.kt)("h2",{id:"logger"},(0,n.kt)("inlineCode",{parentName:"h2"},"logger")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"(message: string) => void")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Option[Context.Logger]")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"null")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"None")," (Scala)")),(0,n.kt)("p",null,"The logger function to record execution traces."),(0,n.kt)("p",null,"To disable the logging, ",(0,n.kt)("inlineCode",{parentName:"p"},"null")," in TypeScript or ",(0,n.kt)("inlineCode",{parentName:"p"},"None")," in Scala should be passed."),(0,n.kt)("h2",{id:"maxattackstringsize"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxAttackStringSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"300000"))),(0,n.kt)("p",null,"The maximum length of the attack string on fuzzing."),(0,n.kt)("h2",{id:"maxdegree"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxDegree")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"4"))),(0,n.kt)("p",null,"The maximum degree to be considered in fuzzing."),(0,n.kt)("h2",{id:"maxgenestringsize"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxGeneStringSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"2400"))),(0,n.kt)("p",null,"The maximum length of the gene string on fuzzing."),(0,n.kt)("h2",{id:"maxgenerationsize"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxGenerationSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"100"))),(0,n.kt)("p",null,"The maximum size of each generation on fuzzing."),(0,n.kt)("h2",{id:"maxinitialgenerationsize"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxInitialGenerationSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"500"))),(0,n.kt)("p",null,"The maximum size of the initial generation on fuzzing."),(0,n.kt)("h2",{id:"maxiteration"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxIteration")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"10"))),(0,n.kt)("p",null,"The maximum number of fuzzing iteration."),(0,n.kt)("h2",{id:"maxnfasize"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxNFASize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"35000"))),(0,n.kt)("p",null,"The maximum size of NFA to determine which algorithm is used."),(0,n.kt)("h2",{id:"maxpatternsize"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxPatternSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"1500"))),(0,n.kt)("p",null,"The maximum size of the regular expression pattern to determine which algorithm is used."),(0,n.kt)("h2",{id:"maxrecallstringsize"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxRecallStringSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"300000"))),(0,n.kt)("p",null,"The maximum length of the attack string on recall validation."),(0,n.kt)("h2",{id:"maxrepeatcount"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxRepeatCount")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"30"))),(0,n.kt)("p",null,"The maximum number of sum of repetition quantifier\u2019s repeat counts to determine which algorithm is used."),(0,n.kt)("h2",{id:"maxsimplerepeatcount"},(0,n.kt)("inlineCode",{parentName:"h2"},"maxSimpleRepeatCount")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"30"))),(0,n.kt)("p",null,"The maximum number of each repetition quantifier\u2019s repeat count on ",(0,n.kt)("inlineCode",{parentName:"p"},"static")," seeding."),(0,n.kt)("h2",{id:"mutationsize"},(0,n.kt)("inlineCode",{parentName:"h2"},"mutationSize")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"50"))),(0,n.kt)("p",null,"The number of mutation on each generation."),(0,n.kt)("h2",{id:"randomseed"},(0,n.kt)("inlineCode",{parentName:"h2"},"randomSeed")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Long")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"0"))),(0,n.kt)("p",null,"The PRNG seed number."),(0,n.kt)("h2",{id:"recalllimit"},(0,n.kt)("inlineCode",{parentName:"h2"},"recallLimit")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"1500000000"))),(0,n.kt)("p",null,"The upper limit on the number of characters read by VM on the recall validation."),(0,n.kt)("h2",{id:"recalltimeout"},(0,n.kt)("inlineCode",{parentName:"h2"},"recallTimeout")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number | null")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"-1000")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration(-1, SECONDS)")," (Scala)")),(0,n.kt)("p",null,"The upper limit of matching time on the recall validation."),(0,n.kt)("p",null,"If this value is negative, then the recall validation is skipped."),(0,n.kt)("h2",{id:"seeder"},(0,n.kt)("inlineCode",{parentName:"h2"},"seeder")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"'static' | 'dynamic'")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Seeder")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"'static'")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Seeder.Static")," (Scala)")),(0,n.kt)("p",null,"The type of seeder to be used in fuzzing."),(0,n.kt)("p",null,"There are two seeders."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"static")," seeder uses the seeding algorithm based on the automata theory."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"dynamic")," seeder uses the seeding algorithm with dynamic analysis.")),(0,n.kt)("h2",{id:"seedinglimit"},(0,n.kt)("inlineCode",{parentName:"h2"},"seedingLimit")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Int")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"1000"))),(0,n.kt)("p",null,"The upper limit on the number of characters read by VM on ",(0,n.kt)("inlineCode",{parentName:"p"},"dynamic")," seeding."),(0,n.kt)("h2",{id:"seedingtimeout"},(0,n.kt)("inlineCode",{parentName:"h2"},"seedingTimeout")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number | null")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"100")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration(100, MILLISECONDS)")," (Scala)")),(0,n.kt)("p",null,"The upper limit of matching time on ",(0,n.kt)("inlineCode",{parentName:"p"},"dynamic")," seeding."),(0,n.kt)("h2",{id:"timeout"},(0,n.kt)("inlineCode",{parentName:"h2"},"timeout")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type: ",(0,n.kt)("inlineCode",{parentName:"li"},"number | null")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration")," (Scala)"),(0,n.kt)("li",{parentName:"ul"},"Default: ",(0,n.kt)("inlineCode",{parentName:"li"},"10000")," (TypeScript), ",(0,n.kt)("inlineCode",{parentName:"li"},"Duration(10, SECONDS)")," (Scala)")),(0,n.kt)("p",null,"The upper limit of checking time."),(0,n.kt)("p",null,"If the checking time exceeds this limit, the result will be reported as ",(0,n.kt)("inlineCode",{parentName:"p"},"timeout"),". If the value is positive infinite in Scala or ",(0,n.kt)("inlineCode",{parentName:"p"},"null")," in TypeScript, the result never becomes ",(0,n.kt)("inlineCode",{parentName:"p"},"timeout"),"."),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"timeout")," time begins to be measured as soon as the check starts. Note that the ",(0,n.kt)("inlineCode",{parentName:"p"},"timeout")," does not occur while the input is in the queue waiting to be checked."),(0,n.kt)("p",null,"In TypeScript, a number value is treated as in milliseconds."))}d.isMDXComponent=!0}}]);